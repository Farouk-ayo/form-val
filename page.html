<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AI for Work: Prompts Form</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&family=Numans&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        padding: 0;
        margin: 0;
        box-sizing: border-box;
        font-family: "Numans", sans-serif;
      }

      @media only screen and (max-width: 49rem) {
        html {
          font-size: 80%;
        }
      }

      .mainForm {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: url("https://softr-prod.imgix.net/applications/adda05be-0ce0-40ae-9d74-683f93a84196/assets/928a7cce-8c7d-4b40-830d-cfe9ce98c891.png");
        background-size: cover;
        background-repeat: no-repeat;
        padding: 5rem 0rem;
        width: 100%;
      }

      .formDetails {
        background: white;
        gap: 2rem;
        padding: 3rem;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 2rem;
        border-radius: 1rem;
        width: 55%;
      }

      @media only screen and (max-width: 79rem) {
        .formDetails {
          width: 70%;
        }
      }
      @media only screen and (max-width: 57rem) {
        .formDetails {
          width: 80%;
        }
      }
      @media only screen and (max-width: 49rem) {
        .formDetails {
          width: 90%;
        }
      }
      @media only screen and (max-width: 39rem) {
        .formDetails {
          padding: 3rem 1rem;
        }
      }

      .formDetails h2 {
        color: #240240;
        font-size: 1.5rem;
        font-family: "Lato", sans-serif;
      }
      .formDetails h4 {
        color: #270346;
        font-size: 1rem;
        font-weight: 100;
      }
      .promptForm {
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
        width: 100%;
        position: relative;
      }

      .eachInput {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: start;
        width: 100%;
        gap: 2rem;
        position: relative;
      }

      @media only screen and (max-width: 29rem) {
        .eachInput {
          gap: 1rem;
        }
      }
      .eachInput span {
        width: 70%;
        position: relative;
      }
      @media only screen and (max-width: 49rem) {
        .eachInput span {
          width: 65%;
        }
      }
      @media only screen and (max-width: 29rem) {
        .eachInput span {
          width: 70%;
        }
      }
      .eachInput label {
        font-size: 1rem;
        color: #616161;
        font-weight: 600;
        width: 30%;
        font-size: 0.8rem;
        padding: 1rem;
      }

      @media only screen and (max-width: 49rem) {
        .eachInput label {
          padding: 0.5rem;
          width: 35%;
        }
      }
      @media only screen and (max-width: 29rem) {
        .eachInput label {
          width: 30%;
        }
      }

      .inputDiv {
        position: relative;
        width: 100%;
      }

      .inputDiv input {
        width: 100%;
        padding: 0.7rem 0.5rem;
        font-size: 0.9rem;
        outline: none;
        border: 0.12rem solid #bab7b7;
        border-radius: 0.5rem;
      }

      @media only screen and (max-width: 29rem) {
        .inputDiv input {
          padding: 0.6rem;
          font-size: 0.7rem;
        }
      }

      .eachInput input::placeholder {
        color: #bab7b7;
        font-weight: 500;
      }
      @media only screen and (max-width: 29rem) {
        .eachInput input::placeholder {
          font-size: 0.7rem;
        }
      }

      .eachInput input:hover {
        border: 0.12rem solid rgb(66, 66, 66);
        transition: all 0.3s;
      }

      .inputDiv textarea {
        width: 100%;
        padding: 0.7rem 0.5rem;
        font-size: 0.9rem;
        outline: none;
        border: 0.12rem solid #bab7b7;
        border-radius: 0.5rem;
        resize: none;
      }
      @media only screen and (max-width: 29rem) {
        .inputDiv textarea {
          padding: 0.5rem;
          font-size: 0.7rem;
        }
      }
      .eachInput textarea::placeholder {
        color: #bab7b7;
        font-weight: 500;
      }

      .eachInput textarea:hover {
        border: 0.12rem solid rgb(66, 66, 66);
        transition: all 0.3s;
      }

      .submit {
        color: white;
        background-color: #7710d2;
        border-radius: 0.5rem;
        box-shadow: rgba(17, 17, 17, 0.04) 0px 2px 4px 0px,
          rgba(33, 33, 33, 0.08) 0px 8px 32px 0px;
        border: none;
        padding: 0.7rem 0rem;
        font-weight: 300;
        font-size: 0.9rem;
      }

      .arrowDown {
        position: absolute;
        top: 50%;
        right: 14px;
        transform: translateY(-50%);
        cursor: pointer;
        transition: transform 0.2s;
      }
      .rotated {
        transform: translateY(-50%) rotate(180deg);
      }

      .suggestions {
        position: absolute;
        display: flex;
        flex-direction: column;
        list-style: none;
        gap: 0.5rem;
        background-color: white;
        width: 100%;
        z-index: 4;
        border-bottom-left-radius: 0.5rem;
        border-bottom-right-radius: 0.5rem;
        box-shadow: rgb(43 52 69 / 10%) 0px 4px 16px;
        display: none;
        overflow-y: scroll;
        max-height: 15rem;
      }

      .show {
        display: block !important;
      }

      .suggestions ul li {
        list-style: none;
        padding: 0.8rem;
        cursor: pointer;
        font-size: 0.8rem;
      }

      .inputDiv:focus-within .arrow-icon {
        transform: rotate(180deg);
      }
      .suggestions li.hovered {
        background-color: #e9e9e9;
      }
      .suggestions li {
        transition: background-color 0.3s ease;
      }

      .suggestions li.selected {
        background-color: #e9e9e9;
      }

      .errorMssg {
        display: flex;
        flex-direction: row;
        align-items: center;
        gap: 0.5rem;
        position: absolute;
        bottom: -1.2rem;
        display: none;
      }
      .error-message {
        color: #de350b;
        font-size: 0.7rem;
      }

      #sourceLink:focus:invalid {
        border-color: #de350b;
      }

      .selected {
        background-color: #d4d2d2;
      }

      #toast {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #1f3f75;
        color: #fff;
        padding: 15px;
        border-radius: 5px;
        display: none;
      }

      #toast.showToast {
        display: block;
        animation: fadeIn 3s forwards;
      }

      @keyframes fadeIn {
        0% {
          opacity: 1;
        }
        100% {
          opacity: 1;
          display: none;
        }
      } /* Loader */
      /* CSS */
      #overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(
          0,
          0,
          0,
          0.5
        ); /* Adjust the alpha value for darkness */
        z-index: 999;
      }
      .loader {
        display: none;
        border: 8px solid #f3f3f3;
        border-top: 8px solid #3498db;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        justify-content: center;
        align-items: center;
      }

      .modal-content {
        background-color: #fff;
        padding: 20px;
        text-align: center;
        border-radius: 5px;
        position: relative;
      }

      .close-modal {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
      }

      /* Add some styling for the success message and icon */
      #success-message {
        color: #4caf50;
        font-size: 24px;
        margin-bottom: 10px;
      }

      #success-icon {
        color: #4caf50;
        font-size: 40px;
        margin-bottom: 20px;
      }
    </style>
  </head>
  <body>
    <main class="mainForm">
      <div class="formDetails">
        <h2>AI For Work: Prompts</h2>
        <h4>Fill out this form to add a Prompt</h4>
        <form class="promptForm" id="myForm">
          <div class="eachInput">
            <label for="promptType">Prompt Type *</label>
            <span>
              <div class="inputDiv">
                <input
                  type="text"
                  id="promptType"
                  name="promptType"
                  placeholder="Select Prompt"
                  required
                />
                <svg
                  class="arrowDown arrowDownType"
                  fill="#bab7b7"
                  height="13px"
                  version="1.1"
                  xmlns="http://www.w3.org/2000/svg"
                  xmlns:xlink="http://www.w3.org/1999/xlink"
                  viewBox="0 0 330 330"
                  xml:space="preserve"
                >
                  <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                  <g
                    id="SVGRepo_tracerCarrier"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  ></g>
                  <g id="SVGRepo_iconCarrier">
                    <path
                      id="XMLID_225_"
                      d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393 c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393 s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"
                    ></path>
                  </g>
                </svg>
              </div>
              <div class="suggestions suggestionsType">
                <ul></ul>
              </div>
            </span>
          </div>

          <div class="eachInput">
            <label for="promptCatg">Prompt Category</label>
            <span>
              <div class="inputDiv">
                <input
                  type="text"
                  id="promptCatg"
                  placeholder="Select Prompt Category"
                  required
                  name="promptCatg"
                />
                <svg
                  class="arrowDown arrowDownCatg"
                  fill="#bab7b7"
                  height="13px"
                  version="1.1"
                  xmlns="http://www.w3.org/2000/svg"
                  xmlns:xlink="http://www.w3.org/1999/xlink"
                  viewBox="0 0 330 330"
                  xml:space="preserve"
                >
                  <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                  <g
                    id="SVGRepo_tracerCarrier"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  ></g>
                  <g id="SVGRepo_iconCarrier">
                    <path
                      id="XMLID_225_"
                      d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393 c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393 s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"
                    ></path>
                  </g>
                </svg>
              </div>
              <div class="suggestions suggestionsCatg">
                <ul></ul>
              </div>
            </span>
          </div>

          <div class="eachInput">
            <label for="promptText">Prompt Text</label>
            <span>
              <div class="inputDiv">
                <textarea
                  name="promptText"
                  id=""
                  cols="30"
                  rows="6"
                  id="promptText"
                  required
                  placeholder="Paste Prompts here"
                ></textarea>
              </div>
            </span>
          </div>
          <div class="eachInput">
            <label for="promptTitle">Prompt Title *</label>
            <span>
              <div class="inputDiv">
                <input
                  type="text"
                  name="promptTitle"
                  id="promptTitle"
                  placeholder="Your Prompt Title Goes Here"
                  required
                />
              </div>
            </span>
          </div>
          <div class="eachInput">
            <label for="sourceLink"> Source Link</label>
            <span>
              <div class="inputDiv">
                <input
                  type="url"
                  id="sourceLink"
                  name="sourceLink"
                  placeholder="http://example.com"
                  value="http://"
                  pattern="https?://(www\.)?.*"
                  required
                />
                <div class="errorMssg">
                  <svg
                    id="errorIcon"
                    fill="#de350b"
                    height="15px"
                    viewBox="0 0 24 24"
                    xmlns="http://www.w3.org/2000/svg"
                  >
                    <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                    <g
                      id="SVGRepo_tracerCarrier"
                      stroke-linecap="round"
                      stroke-linejoin="round"
                    ></g>
                    <g id="SVGRepo_iconCarrier">
                      <path
                        d="M12.884 2.532c-.346-.654-1.422-.654-1.768 0l-9 17A.999.999 0 0 0 3 21h18a.998.998 0 0 0 .883-1.467L12.884 2.532zM13 18h-2v-2h2v2zm-2-4V9h2l.001 5H11z"
                      ></path>
                    </g>
                  </svg>
                  <p class="error-message">Please enter a valid URL.</p>
                </div>
              </div>
            </span>
          </div>
          <div class="eachInput">
            <label for="industry">Industry</label>
            <span>
              <div class="inputDiv">
                <input
                  type="text"
                  name="promptIndustry"
                  id="promptIndustry"
                  placeholder="Select Industry"
                  required
                />
                <svg
                  class="arrowDown arrowDownIndustry"
                  fill="#bab7b7"
                  height="13px"
                  version="1.1"
                  xmlns="http://www.w3.org/2000/svg"
                  xmlns:xlink="http://www.w3.org/1999/xlink"
                  viewBox="0 0 330 330"
                  xml:space="preserve"
                >
                  <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                  <g
                    id="SVGRepo_tracerCarrier"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  ></g>
                  <g id="SVGRepo_iconCarrier">
                    <path
                      id="XMLID_225_"
                      d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393 c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393 s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"
                    ></path>
                  </g>
                </svg>
              </div>
              <div class="suggestions suggestionsIndustry">
                <ul></ul>
              </div>
            </span>
          </div>
          <div class="eachInput">
            <label for="department">Department</label>
            <span>
              <div class="inputDiv">
                <input
                  type="text"
                  name="promptDept"
                  id="promptDept"
                  placeholder="Select Department"
                  required
                />
                <svg
                  class="arrowDown arrowDownDept"
                  fill="#bab7b7"
                  height="13px"
                  version="1.1"
                  xmlns="http://www.w3.org/2000/svg"
                  xmlns:xlink="http://www.w3.org/1999/xlink"
                  viewBox="0 0 330 330"
                  xml:space="preserve"
                >
                  <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                  <g
                    id="SVGRepo_tracerCarrier"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  ></g>
                  <g id="SVGRepo_iconCarrier">
                    <path
                      id="XMLID_225_"
                      d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393 c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393 s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"
                    ></path>
                  </g>
                </svg>
              </div>
              <div class="suggestions suggestionsDept">
                <ul></ul>
              </div>
            </span>
          </div>
          <div class="eachInput">
            <label for="role">Role *</label>
            <span>
              <div class="inputDiv">
                <input
                  type="text"
                  name="promptRole"
                  id="promptRole"
                  placeholder="Select Role"
                  required
                />
                <svg
                  class="arrowDown arrowDownRole"
                  fill="#bab7b7"
                  height="13px"
                  version="1.1"
                  xmlns="http://www.w3.org/2000/svg"
                  xmlns:xlink="http://www.w3.org/1999/xlink"
                  viewBox="0 0 330 330"
                  xml:space="preserve"
                >
                  <g id="SVGRepo_bgCarrier" stroke-width="0"></g>
                  <g
                    id="SVGRepo_tracerCarrier"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                  ></g>
                  <g id="SVGRepo_iconCarrier">
                    <path
                      id="XMLID_225_"
                      d="M325.607,79.393c-5.857-5.857-15.355-5.858-21.213,0.001l-139.39,139.393L25.607,79.393 c-5.857-5.857-15.355-5.858-21.213,0.001c-5.858,5.858-5.858,15.355,0,21.213l150.004,150c2.813,2.813,6.628,4.393,10.606,4.393 s7.794-1.581,10.606-4.394l149.996-150C331.465,94.749,331.465,85.251,325.607,79.393z"
                    ></path>
                  </g>
                </svg>
              </div>
              <div class="suggestions suggestionsRole">
                <ul></ul>
              </div>
            </span>
          </div>
          <button type="submit" class="submit">Submit</button>
        </form>
      </div>
    </main>
    <div id="toast" class="hidden"></div>
    <!-- HTML -->
    <div id="overlay" class="overlay"></div>
    <div id="loader" class="loader"></div>
    <div id="success-modal" class="modal">
      <div class="modal-content">
        <span class="close-modal" onclick="closeModal()">&times;</span>
        <p id="success-icon">✅</p>
        <p id="success-message">Form submitted successfully!</p>
      </div>
    </div>
    <script src="
    https://cdn.jsdelivr.net/npm/airtable@0.12.2/lib/airtable.umd.min.js
    "></script>
    <script>
      document
        .getElementById("sourceLink")
        .addEventListener("input", function (event) {
          let currentValue = event.target.value;

          if (currentValue.startsWith("https://")) {
            currentValue = currentValue.replace(/^http:\/\//, "https://");
          } else if (currentValue.startsWith("www.")) {
            currentValue = "http://" + currentValue;
          }

          event.target.value = currentValue;
        });
      const apiKey =
        "patMrA1yTk0zv7iVa.7f023b4c27161b1c55d49f923c65cbb82aeca4e0842b44a6aca1f984edac12ca";
      const baseId = "app7VXdu27jaUQjIV";
      const airtableApiUrl = `https://api.airtable.com/v0/${baseId}/`;

      let dropdownItems = {};

      const fetchRecords = async (tableId, pageSize = 100, offset = null) => {
        const url = `${airtableApiUrl}${tableId}?pageSize=${pageSize}${
          offset ? `&offset=${offset}` : ""
        }`;

        try {
          const response = await fetch(url, {
            method: "GET",
            headers: {
              accept: "application/json",
              Authorization: `Bearer ${apiKey}`,
            },
          });

          if (!response.ok) {
            throw new Error(
              `Error: ${response.status} - ${response.statusText}`
            );
          }

          return await response.json();
        } catch (error) {
          console.error(`Error fetching records: ${error.message}`);
          throw error;
        }
      };

      const populateDropdown = async (
        tableId,
        htmlTag,
        fieldName,
        // items,
        items = []
      ) => {
        const suggestionsElement = document.querySelector(`.${htmlTag}`);
        suggestionsElement.innerHTML = "<li>Loading...</li>";

        let offset = null;

        try {
          do {
            const data = await fetchRecords(tableId, 100, offset);

            if (data.records) {
              items = items.concat(data.records.map((record) => record.fields));
            }

            console.log(items);
            offset = data.offset;
          } while (offset);

          dropdownItems[fieldName] = items;

          suggestionsElement.innerHTML = "";

          dropdownItems[fieldName].forEach((item) => {
            const li = document.createElement("li");
            if (fieldName === "promptType") {
              li.textContent = item["Prompt Type Names"];
            } else if (fieldName === "promptIndustry") {
              li.textContent = item["Industry Name"];
            } else if (fieldName === "promptCatg") {
              li.textContent = item["Name"];
            } else {
              li.textContent = item[fieldName];
            }
            suggestionsElement.appendChild(li);
          });

          return dropdownItems[fieldName];
        } catch (error) {
          const errorMessage = `Error: ${error.message}`;
          console.error(errorMessage);
          suggestionsElement.innerHTML = `<li>${errorMessage}</li>`;
          return null;
        }
      };

      let promptRoleOptions;

      async function updateSuggestions(departments) {
        const existingPromptRoleOptions = dropdownItems["Role Name"];
        console.log(existingPromptRoleOptions);
        await populateDropdown(
          "tblNOSfTqt31iJZY8",
          "suggestionsRole ul",
          "Role Name"
        );

        const promptRoleOptions = dropdownItems["Role Name"].filter((role) => {
          const roleDepartments = role["Departments"];
          if (roleDepartments) {
            return roleDepartments.some((dept) => departments.includes(dept));
          } else {
            return false;
          }
        });

        console.log(promptRoleOptions);

        const filteredPromptRoleOptions = await populateDropdown(
          "tblNOSfTqt31iJZY8",
          "suggestionsRole ul",
          "Role Name",
          promptRoleOptions
        );
        console.log(filteredPromptRoleOptions);

        const updatedPromptRoleOptions = existingPromptRoleOptions.concat(
          filteredPromptRoleOptions
        );

        if (updatedPromptRoleOptions.length > 0) {
          const roleRecord = updatedPromptRoleOptions.map((role) => {
            dropdownItems["Role Name"] = roleRecord;

            return role;
          });
        }
      }

      async function updateSuggestionsSingle() {
        dropdownItems["promptType"];
        dropdownItems["promptIndustry"];
        dropdownItems["promptCatg"];
        populateDropdown(
          "tbldLUtMAk0sfvwIF",
          "suggestionsType ul",
          "promptType"
        );
        populateDropdown(
          "tblcQPjP9SPEEXmph",
          "suggestionsIndustry ul",
          "promptIndustry"
        );
        populateDropdown(
          "tblFJNzh7J8Bv2Uip",
          "suggestionsCatg ul",
          "promptCatg"
        );
      }

      let selectedPromptType = [];
      let selectedCatg = [];
      let selectedPromptIndustry = [];

      function setupInput(inputElement, suggestionsElement, arrowElement) {
        function toggleArrowAndSuggestions(eventTargetValue) {
          updateSuggestionsSingle();
          suggestionsElement.classList.toggle("show");
          arrowElement.classList.toggle("rotated");
        }

        arrowElement.addEventListener("click", toggleArrowAndSuggestions);
        inputElement.addEventListener("click", toggleArrowAndSuggestions);

        // Add click event listener to each li in the suggestions list
        suggestionsElement.addEventListener("click", function (event) {
          if (
            event.target.tagName === "LI" &&
            event.target.textContent !== "Loading..."
          ) {
            // Set the input value to the clicked li's text content
            inputElement.value = event.target.textContent;
            toggleArrowAndSuggestions(event.target.textContent);
            suggestionsElement.classList.remove("show");
            arrowElement.classList.remove("rotated");

            const matchingPromptType =
              dropdownItems["promptType"] &&
              dropdownItems["promptType"].filter((obj) => {
                return event.target.textContent.includes(
                  obj["Prompt Type Names"]
                );
              });

            if (matchingPromptType.length > 0) {
              selectedPromptType = matchingPromptType;
              dropdownItems["SelectedPromptType"] = selectedPromptType;
              updateSuggestions(dropdownItems["SelectedPromptType"]);
            }

            const matchingPromptIndustry =
              dropdownItems["promptIndustry"] &&
              dropdownItems["promptIndustry"].filter((obj) => {
                return event.target.textContent.includes(obj["Industry Name"]);
              });

            if (matchingPromptIndustry.length > 0) {
              selectedPromptIndustry = matchingPromptIndustry;
              dropdownItems["SelectedPromptIndustry"] = selectedPromptIndustry;
              updateSuggestions(dropdownItems["SelectedPromptIndustry"]);
            }

            const matchingCatg =
              dropdownItems["promptCatg"] &&
              dropdownItems["promptCatg"].filter((obj) => {
                return event.target.textContent.includes(obj.Name);
              });
            if (matchingCatg.length > 0) {
              selectedCatg = matchingCatg;
              dropdownItems["SelectedCatg"] = selectedCatg;
              updateSuggestions(dropdownItems["SelectedCatg"]);
            }
          }
        });
        // Add input event listener to filter suggestions while typing
        inputElement.addEventListener("input", function () {
          filterSuggestions(inputElement.value.trim().toLowerCase());
        });

        // Add mouseover and mouseout event listeners to change background color on hover
        suggestionsElement.addEventListener("mouseover", function (event) {
          if (event.target.tagName === "LI") {
            event.target.classList.add("hovered");
          }
        });

        suggestionsElement.addEventListener("mouseout", function (event) {
          if (event.target.tagName === "LI") {
            event.target.classList.remove("hovered");
          }
        });

        function filterSuggestions(filterText) {
          const suggestions = suggestionsElement.querySelectorAll("li");
          suggestions.forEach((li) => {
            const suggestionText = li.textContent.toLowerCase();
            if (suggestionText.includes(filterText)) {
              li.style.display = "block";
            } else {
              li.style.display = "none";
            }
          });
        }

        // Add global click event listener to close suggestions when clicking outside
        document.addEventListener("click", function (event) {
          if (
            !inputElement.contains(event.target) &&
            !arrowElement.contains(event.target) &&
            !suggestionsElement.contains(event.target)
          ) {
            suggestionsElement.classList.remove("show");
            arrowElement.classList.remove("rotated");
          }
        });
      }

      let selectedDepartments = [];
      let selectedRoles = [];

      // Multiselect input
      function setupMultiSelectInput(
        inputElement,
        suggestionsElement,
        arrowElement
      ) {
        populateDropdown(
          "tbl1L1BhG3RIFZPl9",
          "suggestionsDept ul",
          "Department"
        );
        populateDropdown(
          "tblNOSfTqt31iJZY8",
          "suggestionsRole ul",
          "Role Name"
        );
        let selectedSuggestions = [];
        const allowedSelectors = [
          ".suggestionsDept ul",
          ".suggestionsCatg ul",
          ".suggestionsRole ul",
        ];

        function toggleArrowAndSuggestions(eventTargetValue) {
          arrowElement.classList.add("rotated");
          if (
            !allowedSelectors.some((selector) => {
              return event.target.closest(selector);
            })
          ) {
            suggestionsElement.classList.toggle("show");
          }

          const matchingDepartments =
            dropdownItems["Department"] &&
            dropdownItems["Department"].filter((obj) =>
              eventTargetValue.includes(obj.Department)
            );
          if (matchingDepartments.length > 0) {
            selectedDepartments = matchingDepartments;
            dropdownItems["SelectedDept"] = selectedDepartments;
            updateSuggestions(dropdownItems["SelectedDept"]);
          }
          console.log(matchingDepartments);
          const matchingRole =
            dropdownItems["Role Name"] &&
            dropdownItems["Role Name"].filter((obj) =>
              eventTargetValue.includes(obj["Role Name"])
            );
          selectedRoles = matchingRole;
          dropdownItems["SelectedRole"] = selectedRoles;

          if (matchingDepartments.length > 0) {
            const departmentRecordIds = matchingDepartments.map(
              (dept) => dept["Record ID"]
            );
            dropdownItems["Record IDs"] = departmentRecordIds;
            updateSuggestions(dropdownItems["Record IDs"]);
          }
          console.log(dropdownItems["Record IDs"]);
        }

        arrowElement.addEventListener("click", toggleArrowAndSuggestions);
        inputElement.addEventListener("click", toggleArrowAndSuggestions);

        // Add click event listener to each li in the suggestions list
        suggestionsElement.addEventListener("click", function (event) {
          event.preventDefault();
          event.stopPropagation();
          if (
            event.target.tagName === "LI" &&
            event.target.textContent !== "Loading..."
          ) {
            const clickedSuggestion = event.target.textContent;

            const index = selectedSuggestions.indexOf(clickedSuggestion);

            if (index === -1) {
              selectedSuggestions.push(clickedSuggestion);
              event.target.classList.add("selected");
            } else {
              selectedSuggestions.splice(index, 1);
              event.target.classList.remove("selected");
            }
            toggleArrowAndSuggestions(selectedSuggestions);
            updateInputValue();
          }
        });

        // Update the input value based on selected suggestions
        function updateInputValue() {
          if (selectedSuggestions) {
            inputElement.value = selectedSuggestions.join(", ");
          }
        }

        // Add input event listener to filter suggestions while typing
        inputElement.addEventListener("input", function () {
          const currentValue = inputElement.value
            .split(",")
            .map((item) => item.trim().toLowerCase());
          filterSuggestions(currentValue);
          updateSelectedSuggestions(currentValue);
        });

        // Custom function to find an element containing specific text content
        function findElementByTextContent(parentElement, text) {
          const elements = parentElement.querySelectorAll("li");

          for (const element of elements) {
            if (
              element.textContent.trim().toLowerCase() === text.toLowerCase()
            ) {
              return element;
            }
          }

          return null;
        }

        function updateSelectedSuggestions(currentValue) {
          const newSelectedSuggestions = selectedSuggestions.filter(
            (suggestion) =>
              currentValue.some(
                (value) =>
                  value.trim().toLowerCase() === suggestion.toLowerCase()
              )
          );

          // Iterate over the existing selected suggestions
          selectedSuggestions.forEach((suggestion) => {
            const matchingLi = findElementByTextContent(
              suggestionsElement,
              suggestion
            );

            if (!newSelectedSuggestions.includes(suggestion)) {
              // Remove the selected class from the suggestion
              if (matchingLi) {
                matchingLi.classList.remove("selected");
              }
            }
          });

          // Iterate over the newly selected suggestions
          newSelectedSuggestions.forEach((suggestion) => {
            // Add the selected class to the suggestion if it wasn't selected before
            if (!selectedSuggestions.includes(suggestion)) {
              const matchingLi = findElementByTextContent(
                suggestionsElement,
                suggestion
              );

              if (matchingLi) {
                matchingLi.classList.add("selected");
              }
            }
          });

          // Update the selected suggestions array
          selectedSuggestions = newSelectedSuggestions;

          filterSuggestions(currentValue);
        }

        function filterSuggestions(filterArray) {
          const suggestions = suggestionsElement.querySelectorAll("li");
          suggestions.forEach((li) => {
            const suggestionText = li.textContent.toLowerCase();
            if (
              filterArray.some((filterItem) =>
                suggestionText.includes(filterItem)
              )
            ) {
              li.style.display = "block"; // Show the suggestion
            } else {
              li.style.display = "none"; // Hide the suggestion
            }
          });
        }

        // Add global click event listener to close suggestions when clicking outside
        document.addEventListener("click", function (event) {
          if (
            !inputElement.contains(event.target) &&
            !suggestionsElement.contains(event.target)
          ) {
            suggestionsElement.classList.remove("show");
            arrowElement.classList.remove("rotated");
          }
        });
      }

      // Setup for the first input
      const promptType = document.getElementById("promptType");
      const suggestionsType = document.querySelector(".suggestionsType");
      const arrowType = document.querySelector(".arrowDownType");

      promptType.addEventListener(
        "focus",
        setupInput(promptType, suggestionsType, arrowType)
      );

      // Setup for the second input
      const promptCatg = document.getElementById("promptCatg");
      const suggestionsCatg = document.querySelector(".suggestionsCatg");
      const arrowCatg = document.querySelector(".arrowDownCatg");

      promptCatg.addEventListener(
        "focus",
        setupInput(promptCatg, suggestionsCatg, arrowCatg)
      );

      // Setup for the third input
      const promptIndustry = document.getElementById("promptIndustry");
      const suggestionsIndustry = document.querySelector(
        ".suggestionsIndustry"
      );
      const arrowIndustry = document.querySelector(".arrowDownIndustry");

      promptIndustry.addEventListener(
        "focus",
        setupInput(promptIndustry, suggestionsIndustry, arrowIndustry)
      );

      // Setup for the fourth input
      const promptDept = document.getElementById("promptDept");
      const suggestionsDept = document.querySelector(".suggestionsDept");
      const arrowDept = document.querySelector(".arrowDownDept");

      promptDept.addEventListener(
        "focus",
        setupMultiSelectInput(promptDept, suggestionsDept, arrowDept)
      );

      // Setup for the fifth input
      const promptRole = document.getElementById("promptRole");
      const suggestionsRole = document.querySelector(".suggestionsRole");
      const arrowRole = document.querySelector(".arrowDownRole");

      promptRole.addEventListener(
        "focus",
        setupMultiSelectInput(promptRole, suggestionsRole, arrowRole)
      );
      const sourceLinkInput = document.getElementById("sourceLink");
      const errorMessage = document.querySelector(".errorMssg");

      document.addEventListener("DOMContentLoaded", function () {
        function validateInput() {
          if (!sourceLinkInput.checkValidity()) {
            errorMessage.style.display = "flex";
          } else {
            errorMessage.style.display = "none";
          }
        }
        sourceLinkInput.addEventListener("blur", validateInput);
        sourceLinkInput.addEventListener("input", validateInput);
      });

      const showToast = (message) => {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.add("showToast");

        setTimeout(() => {
          toast.classList.remove("showToast");
        }, 10000);
      };

      const closeModal = () => {
        const modal = document.getElementById("success-modal");
        modal.style.display = "none";
        const overlay = document.getElementById("overlay");
        overlay.style.display = "none";
        window.location.replace(window.location.href);
      };

      const apiKey2 =
        "patMrA1yTk0zv7iVa.7f023b4c27161b1c55d49f923c65cbb82aeca4e0842b44a6aca1f984edac12ca";

      const airtable2 = new Airtable({ apiKey: apiKey2 }).base(
        "app7VXdu27jaUQjIV"
      );

      const addNewEntry = async (formData) => {
        const sourceLink = formData.get("sourceLink");
        const promptCatg = [formData.get("promptCatg")];
        // const promptIndustry = [formData.get("promptIndustry")];

        const catgVal = promptCatg[0];
        const industryVal = promptIndustry[0];

        const promptTitle = formData.get("promptTitle");
        const promptText = formData.get("promptText");
        const promptType = formData.get("promptType");
        const formattedPromptText = `{"prompt":"${promptText}}`;
        const formattedSourceLink = `${sourceLink}`;

        // Create an async function to handle the asynchronous calls
        async function createRecords(tableId, arrays, fieldName) {
          const rolesTable = airtable2(tableId);
          let createdRoles = [];

          for (const nameType of arrays) {
            try {
              const record = await new Promise((resolve, reject) => {
                const data = {
                  [fieldName]: nameType,
                };

                rolesTable.create(data, (err, record) => {
                  if (err) {
                    reject(err);
                  } else {
                    resolve(record);
                  }
                });
              });

              createdRoles.push(record.getId());
            } catch (error) {
              console.error(`Error creating record for ${nameType}: ${error}`);
            }
          }

          return createdRoles;
        }
        const promptDepartment = formData
          .get("promptDept")
          .split(",")
          .map((item) => item.trim());

        const promptRoles = formData
          .get("promptRole")
          .split(",")
          .map((item) => item.trim());

        // const promptCatg = formData
        //   .get("promptCatg")
        //   .split(",")
        //   .map((item) => item.trim());

        // const promptIndustry = formData
        //   .get("promptIndustry")
        //   .split(",")
        //   .map((item) => item.trim());

        const departmentRecordIds = await createRecords(
          "tbl1L1BhG3RIFZPl9",
          promptDepartment,
          "Department"
        );

        const roleRecordIds = await createRecords(
          "tblNOSfTqt31iJZY8",
          promptRoles,
          "Role Name"
        );

        // const industryRecordIds = await createRecords(
        //   "tblcQPjP9SPEEXmph",
        //   promptIndustry,
        //   "Industry Name"
        // );

        // const categoryRecordIds = await createRecords(
        //   "tblFJNzh7J8Bv2Uip",
        //   promptCatg,
        //   "Name"
        // );

        const selectedDeptRecordIds =
          dropdownItems["SelectedDept"]?.map((obj) => obj["Record ID"]) || [];

        const selectedRoleRecordIds = dropdownItems["SelectedRole"]?.map(
          (obj) => obj["Record ID"] || []
        );

        const selectedCatgIds = dropdownItems["SelectedCatg"]?.map(
          (obj) => obj["Record ID"] || []
        );

        const selectedPromptType = dropdownItems["SelectedPromptType"]?.map(
          (obj) => obj["Record ID"] || []
        );
        const selectedPromptIndustry = dropdownItems[
          "SelectedPromptIndustry"
        ]?.map((obj) => obj["Record ID"] || []);

        console.log(categoryRecordIds);
        console.log(industryRecordIds);

        const finalDeptRecordIds =
          Array.isArray(selectedDeptRecordIds) ||
          selectedDeptRecordIds.length === 0
            ? departmentRecordIds
            : selectedDeptRecordIds;

        const finalRoleRecordIds =
          selectedRoleRecordIds === undefined
            ? roleRecordIds
            : selectedRoleRecordIds;

        const submitButton = document.querySelector(".submit");
        submitButton.textContent = "Submitting...";

        try {
          const loader = document.getElementById("loader");
          const modal = document.getElementById("success-modal");
          const overlay = document.getElementById("overlay");
          const tableId = "tblWxjOgN18FFMQ6k";
          loader.style.display = "block";

          modal.addEventListener("click", closeModal);

          console.log(catgVal);

          const response = await fetch(`${airtableApiUrl}${tableId}`, {
            headers: {
              accept: "application/json",
              Authorization: `Bearer ${apiKey}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              records: [
                {
                  fields: {
                    "Prompt Departments": finalDeptRecordIds,
                    "Prompt Roles": finalRoleRecordIds,
                    "Prompt Category.": catgVal,
                    "Prompt Title": promptTitle,
                    "Prompt Link": formattedSourceLink,
                    "Prompt Text": formattedPromptText,
                    // "Prompt Type": selectedPromptType,
                    // "Prompt Industry": industryRecordIds,
                  },
                },
              ],
            }),
            method: "POST",
          });
          console.log(response);
          if (response.ok) {
            submitButton.disabled = true;
            const data = await response.json();
            console.log(data);
            const form = document.getElementById("myForm");
            form.reset();
            // showToast("Successfully submitted!");
            loader.style.display = "none";
            modal.style.display = "block";
            overlay.style.display = "block";
          } else {
            console.log(response);
            console.error("Error:", response.status, response.statusText);
            submitButton.disabled = false;

            showToast("Submission failed");
          }
        } catch (error) {
          console.error("Error:", error);
          showToast("Submission failed");
        } finally {
          overlay.style.display = "none";
          loader.style.display = "none";
          submitButton.textContent = "Submit";
          submitButton.disabled = false;
        }
      };
      const form = document.getElementById("myForm");
      const overlay = document.getElementById("overlay");

      form.addEventListener("submit", function (event) {
        event.preventDefault();
        const formData = new FormData(event.target);
        overlay.style.display = "block";

        addNewEntry(formData);
      });

      form.addEventListener("keydown", function (event) {
        if (event.keyCode === 13) {
          event.preventDefault();
          overlay.style.display = "block";
          const modal = document.getElementById("success-modal");
          modal.style.display = "none";
          const formData = new FormData(event.target);
          addNewEntry(formData);
        }
      });
    </script>
  </body>
</html>
